@page "/BadDaysHelper"
@using System.Text.Json
@using System.Text.RegularExpressions
@using VTools.BadDayPostAggregate
@using VTools.BadDayPostAggregate.Commands
@inject IJSRuntime JsRuntime;
@inject IBadDayPostDomain BadDayPostDomain;

@rendermode InteractiveServer

<h2>BadDays Helper</h2>
<h3>Import File</h3>

<div class="input-group mb-3">
    <input type="number" class="form-control" placeholder="Max file size" @bind="_maxFileSize">
    <input type="number" class="form-control" placeholder="Max allowed files" @bind="_maxAllowedFiles">
    Upload up to @_maxAllowedFiles of up to @_maxFileSize bytes:
    <InputFile class="btn btn-outline-success" id="button-addon2" OnChange="LoadFile" accept=".csv,.txt">
        <i class="bi bi-plus"></i>
    </InputFile>
</div>

@if (_isLoading)
{
    <p>Uploading...</p>
}
else
{
    <table class="table">
        <thead>
        <tr>
            <th>Type</th>
            <th>Url</th>
            <th>Id</th>
            <th>Origin</th>
            <th></th>
        </tr>
        </thead>
        <tbody>
        @foreach (var post in _postImports)
    {
        <tr>
            <td>@post.Type</td>
            <td>@post.Url</td>
            <td>@post.Id</td>
            <td>@post.Origin</td>
            <td>
                <button type="button" class="btn btn-outline-primary" @onclick="@(() => Show(post.Id))">Show</button>
                </td>
            </tr>
        }
        </tbody>
    </table>
}

<div class="input-group mb-3">
    <input type="text" class="form-control" placeholder="Max file size" @bind="_idSelected">
    <button type="button" class="btn btn-outline-primary" @onclick="@(() => Show())">Show</button>
</div>

@if (string.IsNullOrEmpty(_idSelected) is false)
{
    <iframe src="https://www.instagram.com/p/@(_idSelected)/embed"
            width="540"
            height="600"
            frameborder="0"
            scrolling="no"
            allowtransparency>
    </iframe>
}

@if (string.IsNullOrEmpty(_errorMessage) is false)
{
    <p>@_errorMessage</p>
}

@if (string.IsNullOrEmpty(_result) is false)
{
    <textarea class="form-control" aria-multiline="true" rows="20" aria-label="_result" aria-describedby="_result" @bind="@_result"></textarea>
}

<h3>Show database</h3>
<button type="button" class="btn btn-outline-primary" @onclick="@(() => Save())">Save In Database</button>

@code {

    // TODO : Amélioration :
    // Créer une base de donnée dans laquelle sera stockée tous les posts (unicité sur l'id)
    // Lister tous les posts
    // A chaque nouveau fichier, lister comme c'est le cas ici tous nouveaux posts mais en décochant ceux qui sont déjà présent en base
    // Et en prégénérant le fichier
    // Dès qu'on coche ou décoche une ligne il regénère un result
    // Un bouton pour save en base les nouvelles lignes et télécharger le fichier d'id
    // Voir s'il est possible de se connecter à github pour push directement les modifications

    private long _maxFileSize = 1024 * 15;
    private int _maxAllowedFiles = 3;
    private bool _isLoading;

    private List<PostImport> _postImports = [];

    private string _errorMessage = string.Empty;
    private string _result = string.Empty;
    private string _idSelected = string.Empty;

    private async Task LoadFile(InputFileChangeEventArgs e)
    {
        _isLoading = true;

        var file = e.GetMultipleFiles(_maxAllowedFiles).FirstOrDefault();

        if (file is not null)
        {
            try
            {
                var stream = file.OpenReadStream();

                using var reader = new StreamReader(stream);

                var line = string.Empty;

                while ((line = await reader.ReadLineAsync()) != null)
                {
                    ConvertToPostImport(line);
                    Console.WriteLine(line);
                }
            }
            catch (Exception ex)
            {
                _errorMessage = $"File: {file.Name} Error: {ex.Message}";
            }
        }

        _isLoading = false;
    }

    private void ConvertToPostImport(string line)
    {
        var result = line.Split("|");

        _postImports.Add(new PostImport(result[0], result[1], result[2]));

        ProcessResult();
    }

    private void ProcessResult()
    {
        _result = ConvertToJson(_postImports);
    }

    private string ConvertToJson(List<PostImport> postImports)
    {
        var jsonObjectArray = new object[postImports.Count];

        for (var i = 0; i < postImports.Count; i++)
        {
            jsonObjectArray[i] = new
            {
                Name = "Init import",
                postImports[i].Url,
                postImports[i].Id,
                Type = 3
            };
        }

        return JsonSerializer.Serialize(jsonObjectArray, new JsonSerializerOptions
        {
            WriteIndented = true // pour une sortie JSON beautifiée
        });
    }

    private async Task Show(string? postId = null)
    {
        if (postId is not null)
        {
            _idSelected = postId;
        }

        await JsRuntime.InvokeVoidAsync("refreshInstagramEmbed");
    }


    public class PostImport
    {
        public string Type { get; }
        public string Url { get; }
        public string Id { get; }
        public string? Origin { get; }

        public PostImport(string type, string url, string? origin)
        {
            Type = type;
            Url = url;
            Id = GetId(url);
            Origin = origin;
        }

        private string GetId(string url)
        {
            const string pattern = @"(?:reel|p)\/([^\/?]+)";

            var match = Regex.Match(url, pattern);
            return match.Success ? match.Groups[1].Value : string.Empty;
        }
    }

    private async Task Save()
    {
        foreach (var postImport in _postImports)
        {
            Console.WriteLine($"Import post : {postImport.Id}");

            await BadDayPostDomain.CreateAsync(new CreateBadDayPostCommand(postImport.Id, postImport.Url));
        }

        Console.WriteLine("Finish !");
    }

}