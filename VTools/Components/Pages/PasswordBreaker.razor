@page "/PasswordBreaker"
@rendermode InteractiveServer
@attribute [StreamRendering]

<h3>PasswordBreaker</h3>

<input type="text" class="form-control" placeholder="Password to break" aria-label="Password to break" aria-describedby="PasswordToBreak" @bind="_passwordToBreak">

<button class="btn btn-outline-success" type="button" id="button-addon2" @onclick="@(() => Break())">Test to Break</button>

<p>@_passwordTest</p>
<p>@_result</p>

@code {

    private string _upperChars =
        Enumerable.Range('A', 26).Select(c => (char)c)
            .ToString();

    private char[] _lowerChars =
        Enumerable.Range('a', 26).Select(c => (char)c)
            .ToArray();

    private char[] _numericChars =
        Enumerable.Range('0', 10).Select(c => (char)c)
            .ToArray();

    private string _passwordToBreak = string.Empty;
    private string _passwordTest = string.Empty;
    private string _result = string.Empty;

    private async Task Break()
    {
        _result = string.Empty;

        var result = await BruteForceSearch(_passwordToBreak);

        _result = $"SUCCESS ! => {result}";
    }

    async Task<string> BruteForceSearch(string target)
    {
        const string chars = "abcdefghijklmnopqrstuvwxyz"; // Ensemble des caractères à tester
        var length = 1; // Longueur actuelle des chaînes à tester

        while (true)
        {
            foreach (var combination in GenerateCombinations(chars, length))
            {
                _passwordTest = combination;
                StateHasChanged();

                if (combination == target)
                {
                    return combination; // Chaîne trouvée
                }

                // await Task.Delay(1); // Ajoute un petit délai pour visualiser chaque étape
            }
            await Task.Delay(1); // Ajoute un petit délai pour visualiser chaque étape

            length++; // Augmente la longueur des combinaisons à tester
        }
    }

    IEnumerable<string> GenerateCombinations(string chars, int length)
    {
        // Utilise une approche récursive pour générer toutes les combinaisons d'une certaine longueur
        if (length == 1)
        {
            foreach (var c in chars)
            {
                yield return c.ToString();
            }
        }
        else
        {
            foreach (var c in chars)
            {
                foreach (var sub in GenerateCombinations(chars, length - 1))
                {
                    yield return c + sub;
                }
            }
        }
    }

}